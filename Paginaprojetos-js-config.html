<script>
  const STATUS_ETAPAS = { A_FAZER: 'A Fazer', EM_ANDAMENTO: 'Em Andamento', BLOQUEADA: 'Bloqueada', CONCLUIDA: 'Concluída' };
    const CONFIG = { 
  ZOOM_MIN: 0.3, 
  ZOOM_MAX: 2.5, 
  OFFSET_RESP_Y: 180, 
  OFFSET_ETAPA_Y: 130,        // CORRIGIDO: Era 100
  OFFSET_ETAPA_FILHA_Y: 100,  // CORRIGIDO: Era 80
  OFFSET_ETAPA_FILHA_X: 40,   // CORRIGIDO: Era 30
  POS_INICIAL_X: 100, 
  POS_INICIAL_Y: 80 
};
    const CONFIG_LAYOUT_FLUIDO = { DETECTAR_COLISAO_ARRASTE: true };
    const CONFIG_COLISAO = { MARGEM_SEGURANCA: 20, DIRECAO_DESLOCAMENTO: 'baixo', ANIMAR_DESLOCAMENTO: true, DURACAO_ANIMACAO: 200 };
    const CONFIG_ORGANIZACAO = {
  TIPOS_LAYOUT: {
    ARVORE_VERTICAL: 'arvoreVertical',
    ARVORE_HORIZONTAL: 'arvoreHorizontal',
    GRADE: 'grade'
  },
  ESPACAMENTO_PADRAO: 120,
  ESPACAMENTO_MIN: 60,
  ESPACAMENTO_MAX: 200
};

    // Configurações globais para as linhas de conexão
    const CONFIG_LINHAS = {
      RAIO_CURVA_PADRAO: 20,
      RAIO_CURVA_HIERARQUIA: 15,
      RAIO_CURVA_VINCULO: 25
    };

    function obterRetanguloCard(cardId) {
      const el = document.getElementById(cardId);
      if (!el) return null;
      const x = parseFloat(el.style.left) || 0;
      const y = parseFloat(el.style.top) || 0;
      return { id: cardId, x: x, y: y, largura: el.offsetWidth, altura: el.offsetHeight, direita: x + el.offsetWidth, baixo: y + el.offsetHeight };
    }

    function verificarColisao(rect1, rect2) {
      if (!rect1 || !rect2) return false;
      const margem = CONFIG_COLISAO.MARGEM_SEGURANCA;
      const r1 = { x: rect1.x - margem, y: rect1.y - margem, direita: rect1.direita + margem, baixo: rect1.baixo + margem };
      return !(r1.direita < rect2.x || r1.x > rect2.direita || r1.baixo < rect2.y || r1.y > rect2.baixo);
    }

    function obterTodosCardsDoTipo(tipo) {
      const seletores = { projeto: '.card-projeto', etapa: '.card-etapa', setor: '.card-setor', responsavel: '.card-responsavel' };
      return Array.from(document.querySelectorAll(seletores[tipo] || '')).map(el => el.id);
    }

    function encontrarColisoes(cardIdMovendo, tipo) {
      const rectMovendo = obterRetanguloCard(cardIdMovendo);
      if (!rectMovendo) return [];
      const todosCards = obterTodosCardsDoTipo(tipo);
      const colisoes = [];
      todosCards.forEach(cardId => {
        if (cardId === cardIdMovendo) return;
        const rectOutro = obterRetanguloCard(cardId);
        if (verificarColisao(rectMovendo, rectOutro)) colisoes.push({ id: cardId, rect: rectOutro });
      });
      return colisoes;
    }

    function calcularPosicaoSemColisao(rectMovendo, rectParado) {
      const margem = CONFIG_COLISAO.MARGEM_SEGURANCA;
      let novoX = rectParado.x;
      let novoY = rectParado.y;
      if (CONFIG_COLISAO.DIRECAO_DESLOCAMENTO === 'inteligente') {
        const dBaixo = rectMovendo.baixo - rectParado.y;
        const dDireita = rectMovendo.direita - rectParado.x;
        const dCima = rectParado.baixo - rectMovendo.y;
        const dEsquerda = rectParado.direita - rectMovendo.x;
        const menor = Math.min(dBaixo, dDireita, dCima, dEsquerda);
        if (menor === dBaixo) novoY = rectMovendo.baixo + margem;
        else if (menor === dDireita) novoX = rectMovendo.direita + margem;
        else if (menor === dCima) novoY = rectMovendo.y - rectParado.altura - margem;
        else novoX = rectMovendo.x - rectParado.largura - margem;
      } else if (CONFIG_COLISAO.DIRECAO_DESLOCAMENTO === 'baixo') {
        novoY = rectMovendo.baixo + margem;
      } else if (CONFIG_COLISAO.DIRECAO_DESLOCAMENTO === 'direita') {
        novoX = rectMovendo.direita + margem;
      }
      return { novoX, novoY };
    }

    function deslocarCard(cardId, novoX, novoY, tipo) {
      const el = document.getElementById(cardId);
      if (!el) return;
      if (CONFIG_COLISAO.ANIMAR_DESLOCAMENTO) {
        el.style.transition = `left ${CONFIG_COLISAO.DURACAO_ANIMACAO}ms ease, top ${CONFIG_COLISAO.DURACAO_ANIMACAO}ms ease`;
        el.classList.add('card-deslocando');
      }
      el.style.left = novoX + 'px';
      el.style.top = novoY + 'px';
      if (CONFIG_COLISAO.ANIMAR_DESLOCAMENTO) {
        setTimeout(() => { el.style.transition = ''; el.classList.remove('card-deslocando'); }, CONFIG_COLISAO.DURACAO_ANIMACAO);
      }
      const idReal = cardId.replace(/^(projeto-|etapa-|setor-|responsavel-)/, '');
      atualizarModeloPosicao(tipo, idReal, novoX, novoY);
      salvarPosicaoAsync(tipo, idReal, novoX, novoY);
      atualizarConexoesParciais(tipo, idReal);
    }

    function processarColisoesCascata(cardIdOrigem, tipo, jaProcessados = new Set()) {
      if (jaProcessados.has(cardIdOrigem)) return;
      jaProcessados.add(cardIdOrigem);
      const colisoes = encontrarColisoes(cardIdOrigem, tipo);
      const rectOrigem = obterRetanguloCard(cardIdOrigem);
      colisoes.forEach(colisao => {
        if (jaProcessados.has(colisao.id)) return;
        const novaPosicao = calcularPosicaoSemColisao(rectOrigem, colisao.rect);
        deslocarCard(colisao.id, novaPosicao.novoX, novaPosicao.novoY, tipo);
        setTimeout(() => processarColisoesCascata(colisao.id, tipo, jaProcessados), 50);
      });
    }

    function resolverColisoesInteligente(cardId, tipo) {
      const el = document.getElementById(cardId || (estado.elementoArrastando ? estado.elementoArrastando.id : null));
      if (!el) return;
      processarColisoesCascata(el.id, tipo);
    }

    // ============================================================
    // IMPORTANTE: Inicializa dadosDiagrama com prioridadesPorResponsavel
    // ============================================================
    let dadosDiagrama = { 
      projetos: [], 
      responsaveis: [], 
      vinculos: [], 
      etapas: [], 
      dependencias: [],
      setoresResponsaveis: [],
      prioridadesPorResponsavel: new Map() // Cache de prioridades por responsável
    };

    let permissoesUsuario = {
      nivelAcesso: 'visitante',
      podeCriarProjeto: false,
      podeCriarEtapa: false,
      ehAdmin: false,
      setoresPermitidos: [],
      projetosPermitidos: []
    };

    const NIVEIS_ACESSO = {
      ADMIN: 'admin',
      GESTOR: 'gestor',
      COLABORADOR: 'colaborador'
    };
    
    let estado = {
      zoom: 1, offsetX: 0, offsetY: 0, arrastandoPan: false, inicioX: 0, inicioY: 0,
      elementoArrastando: null, tipoArrastando: null, idArrastando: null, timeoutColisaoArraste: null,
      projetosExpandidos: new Set(), etapasExpandidas: new Set(), etapasFilhasColapsadas: new Set(),
      responsaveisColapsados: new Set(), conectandoEtapa: null, anchorOrigem: null, pontoOrigem: null,
      conectandoResponsavel: null, anchorRespOrigem: null, pontoRespOrigem: null,
      filtroResponsaveis: new Set(), filtroStatus: new Set(['A Fazer', 'Em Andamento', 'Bloqueada', 'Concluída']),
      posicoesSetores: {}, setoresColapsados: new Set(), setoresDetalhesExpandidos: new Set(),
      projetosEtapasVisiveis: new Set(), ocultarEtapasAbertas: false, ocultarTodosProjetos: false,
      modoMovimentoSetorIndependente: new Set(),
      colaboradorExpandido: null,
      frameArrasteAgendado: false, layoutSelecionado: 'arvoreVertical',
      espacamentoLayout: 120,deslocamentosAtivos: new Map(),secaoColaboradorVisivel: new Map(),

      prioridadesEditando: {
        responsavelId: null,
        listaPrioridades: [], // Array de {tipoItem: 'projeto'|'etapa', itemId: string}
        prioridadesOriginais: [] // Para possibilitar cancelamento
      }

    };
    let cacheConexoes = { porProjeto: new Map(), porEtapa: new Map(), porResponsavel: new Map() };
    let cachePosicoesEtapas = new Map();
    let modoEdicaoGlobal = true;
    let podeEditarBackend = true;
    let callbackConfirmacao = null;
    let valorAnteriorPendentes = 0;
    
    // Funções auxiliares de Responsáveis e Herança
    
    // Obtém o gerente de um setor
    function obterGerenteSetor(nomeSetor) {
      try {
        if (!nomeSetor) return null;
        if (typeof dadosDiagrama === 'undefined') return null;
        if (!dadosDiagrama) return null;
        if (!dadosDiagrama.setoresResponsaveis) return null;
        if (!dadosDiagrama.responsaveis) return null;
        
        const setorInfo = dadosDiagrama.setoresResponsaveis.find(s => s && s.nomeSetor === nomeSetor);
        if (!setorInfo || !setorInfo.responsavelId) return null;
        
        return dadosDiagrama.responsaveis.find(r => r && r.id === setorInfo.responsavelId) || null;
      } catch (e) {
        console.warn('Erro em obterGerenteSetor:', e);
        return null;
      }
    }

    // NOVA FUNÇÃO: Retorna lista de responsáveis do projeto (suporta múltiplos)
    function obterResponsaveisProjeto(projeto) {
      try {
        if (!projeto) return [];
        const responsaveis = [];
        
        // 1. Responsáveis diretos do projeto (Array de IDs)
        if (projeto.responsaveisIds && projeto.responsaveisIds.length > 0) {
          projeto.responsaveisIds.forEach(id => {
            const resp = dadosDiagrama.responsaveis.find(r => r && r.id === id);
            if (resp) responsaveis.push({ ...resp, herdado: false });
          });
        }
        
        // 2. Se não tem diretos, herda do setor
        if (responsaveis.length === 0) {
          const gerente = obterGerenteSetor(projeto.setor);
          if (gerente) responsaveis.push({ ...gerente, herdado: true });
        }
        
        return responsaveis;
      } catch (e) {
        console.warn('Erro em obterResponsaveisProjeto:', e);
        return [];
      }
    }

    // NOVA FUNÇÃO: Retorna lista de responsáveis da etapa (suporta múltiplos)
    function obterResponsaveisEtapa(etapa) {
      try {
        if (!etapa) return [];
        const responsaveis = [];
        
        // 1. Responsáveis diretos da etapa
        if (etapa.responsaveisIds && etapa.responsaveisIds.length > 0) {
          etapa.responsaveisIds.forEach(id => {
            const resp = dadosDiagrama.responsaveis.find(r => r && r.id === id);
            if (resp) responsaveis.push({ ...resp, herdado: false });
          });
        }
        
        // 2. Se não tem diretos, herda do projeto
        if (responsaveis.length === 0) {
          const projeto = dadosDiagrama.projetos.find(p => p && p.id === etapa.projetoId);
          const respsProj = obterResponsaveisProjeto(projeto);
          respsProj.forEach(r => responsaveis.push({ ...r, herdado: true }));
        }
        
        return responsaveis;
      } catch (e) {
        console.warn('Erro em obterResponsaveisEtapa:', e);
        return [];
      }
    }

    // Alias para compatibilidade com código antigo (retorna o primeiro ou null)
    function obterResponsavelProjeto(projeto) {
       const resps = obterResponsaveisProjeto(projeto);
       return resps.length > 0 ? resps[0] : null;
    }
    
    function obterResponsavelEtapa(etapa) {
       const resps = obterResponsaveisEtapa(etapa);
       return resps.length > 0 ? resps[0] : null;
    }

    function podeEditarProjetoLocal(projetoId) {
      if (permissoesUsuario.ehAdmin) return true;
      if (!permissoesUsuario.nivelAcesso || permissoesUsuario.nivelAcesso === 'visitante') return false;
      
      // Gestor pode editar projetos do seu setor
      if (permissoesUsuario.nivelAcesso === NIVEIS_ACESSO.GESTOR) {
        const projeto = dadosDiagrama.projetos.find(p => p.id === projetoId);
        if (projeto && projeto.setor && permissoesUsuario.setoresPermitidos.includes(projeto.setor)) {
          return true;
        }
      }
      
      // Colaborador não pode editar projetos
      return false;
    }

    function podeEditarEtapaLocal(etapaId) {
      if (permissoesUsuario.ehAdmin) return true;
      if (!permissoesUsuario.nivelAcesso || permissoesUsuario.nivelAcesso === 'visitante') return false;
      
      const etapa = dadosDiagrama.etapas.find(e => e.id === etapaId);
      if (!etapa) return false;
      
      // Gestor pode editar etapas do seu setor
      if (permissoesUsuario.nivelAcesso === NIVEIS_ACESSO.GESTOR) {
        const projeto = dadosDiagrama.projetos.find(p => p.id === etapa.projetoId);
        if (projeto && projeto.setor && permissoesUsuario.setoresPermitidos.includes(projeto.setor)) {
          return true;
        }
      }
      
      // Colaborador pode editar etapas onde está atribuído
      if (permissoesUsuario.nivelAcesso === NIVEIS_ACESSO.COLABORADOR) {
        // Busca o responsável pelo email do usuário
        const emailUsuario = permissoesUsuario.email?.toLowerCase();
        if (emailUsuario) {
          const resp = dadosDiagrama.responsaveis.find(r => 
            r.email && r.email.toLowerCase() === emailUsuario
          );
          if (resp && etapa.responsaveisIds && etapa.responsaveisIds.includes(resp.id)) {
            return true;
          }
        }
      }
      
      return false;
    }

    /**
     * Verifica se pode criar projetos
     */
    function podeCriarProjetoLocal() {
      return permissoesUsuario.ehAdmin || permissoesUsuario.podeCriarProjeto;
    }

    /**
     * Verifica se pode criar etapas em um projeto
     */
    function podeCriarEtapaLocal(projetoId) {
      if (permissoesUsuario.ehAdmin) return true;
      if (!permissoesUsuario.podeCriarEtapa) return false;
      
      // Verifica se o projeto está visível (já passou pelo filtro do backend)
      const projeto = dadosDiagrama.projetos.find(p => p.id === projetoId);
      return !!projeto;
    }

    /**
     * Obtém a prioridade de um item para um responsável específico
     * @param {string} tipoItem - 'projeto' ou 'etapa'
     * @param {string} itemId - ID do item
     * @param {string} responsavelId - ID do responsável
     * @returns {number|null} - Número da prioridade ou null
     */
    function obterPrioridadeItem(tipoItem, itemId, responsavelId) {
      // ============================================================
      // CORREÇÃO: Verificação de segurança
      // ============================================================
      if (!dadosDiagrama || !dadosDiagrama.prioridadesPorResponsavel) return null;
      
      const chave = responsavelId;
      if (!dadosDiagrama.prioridadesPorResponsavel.has(chave)) return null;
      
      const lista = dadosDiagrama.prioridadesPorResponsavel.get(chave);
      if (!lista || !Array.isArray(lista)) return null;
      
      const item = lista.find(p => p.tipoItem === tipoItem && p.itemId === itemId);
      return item ? item.ordemPrioridade : null;
    }

    /**
     * Obtém a maior prioridade (menor número) de um projeto considerando todos os responsáveis
     * CORRIGIDO: Verificação de segurança antes de usar forEach
     */
    function obterMaiorPrioridadeProjeto(projetoId) {
      // ============================================================
      // CORREÇÃO: Verificação de segurança antes de usar forEach
      // ============================================================
      if (!dadosDiagrama) return null;
      if (!dadosDiagrama.prioridadesPorResponsavel) return null;
      if (!(dadosDiagrama.prioridadesPorResponsavel instanceof Map)) return null;
      if (dadosDiagrama.prioridadesPorResponsavel.size === 0) return null;
      
      let menorPrioridade = null;
      
      dadosDiagrama.prioridadesPorResponsavel.forEach((lista, respId) => {
        if (!lista || !Array.isArray(lista)) return;
        
        const item = lista.find(p => p.tipoItem === 'projeto' && p.itemId === projetoId);
        if (item) {
          if (menorPrioridade === null || item.ordemPrioridade < menorPrioridade) {
            menorPrioridade = item.ordemPrioridade;
          }
        }
      });
      
      return menorPrioridade;
    }

    function escaparHtml(t) {
      if (t == null) return '';
      const d = document.createElement('div');
      d.textContent = String(t);
      return d.innerHTML;
    }

    function obterCaminhoOrtogonal(p1, p2, tipo) {
      const { x: x1, y: y1 } = p1;
      const { x: x2, y: y2 } = p2;
      
      const RAIO_CURVA = CONFIG_LINHAS.RAIO_CURVA_PADRAO || 20;

      if (tipo === 'vertical') {
        const midY = (y1 + y2) / 2;
        const distX = Math.abs(x2 - x1);
        const distY = Math.abs(y2 - y1);
        const raio = Math.min(RAIO_CURVA, distX / 2, distY / 4);

        if (distX < 2) {
          return `M ${x1} ${y1} L ${x2} ${y2}`;
        }

        const direcaoX = x2 > x1 ? 1 : -1;

        return `M ${x1} ${y1}
                L ${x1} ${midY - raio}
                Q ${x1} ${midY} ${x1 + raio * direcaoX} ${midY}
                L ${x2 - raio * direcaoX} ${midY}
                Q ${x2} ${midY} ${x2} ${midY + raio}
                L ${x2} ${y2}`;
      } 
      else if (tipo === 'horizontal') {
        const midX = (x1 + x2) / 2;
        const distX = Math.abs(x2 - x1);
        const distY = Math.abs(y2 - y1);
        const raio = Math.min(RAIO_CURVA, distX / 4, Math.abs(distY) / 2);

        if (distY < 2) {
          return `M ${x1} ${y1} L ${x2} ${y2}`;
        }

        const direcaoY = y2 > y1 ? 1 : -1;

        return `M ${x1} ${y1}
                L ${midX - raio} ${y1}
                Q ${midX} ${y1} ${midX} ${y1 + raio * direcaoY}
                L ${midX} ${y2 - raio * direcaoY}
                Q ${midX} ${y2} ${midX + raio} ${y2}
                L ${x2} ${y2}`;
      } 
      else if (tipo === 'hierarquia') {
        const distX = Math.abs(x2 - x1);
        const distY = Math.abs(y2 - y1);
        const raio = Math.min(RAIO_CURVA, distX, distY / 2);

        if (distX < 2) {
          return `M ${x1} ${y1} L ${x2} ${y2}`;
        }

        const direcaoX = x2 > x1 ? 1 : -1;

        return `M ${x1} ${y1}
                L ${x1} ${y2 - raio}
                Q ${x1} ${y2} ${x1 + raio * direcaoX} ${y2}
                L ${x2} ${y2}`;
      }
      
      return `M ${x1} ${y1} L ${x2} ${y2}`;
    }

    function obterCaminhoCurvaSuave(p1, p2, tipo) {
      const { x: x1, y: y1 } = p1;
      const { x: x2, y: y2 } = p2;
      
      const TENSAO = 0.4;

      if (tipo === 'vertical') {
        const distY = y2 - y1;
        const cp1y = y1 + distY * TENSAO;
        const cp2y = y2 - distY * TENSAO;
        return `M ${x1} ${y1} C ${x1} ${cp1y}, ${x2} ${cp2y}, ${x2} ${y2}`;
      } 
      else if (tipo === 'horizontal') {
        const distX = x2 - x1;
        const cp1x = x1 + distX * TENSAO;
        const cp2x = x2 - distX * TENSAO;
        return `M ${x1} ${y1} C ${cp1x} ${y1}, ${cp2x} ${y2}, ${x2} ${y2}`;
      } 
      else if (tipo === 'hierarquia') {
        const midY = (y1 + y2) / 2;
        return `M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}`;
      }

      return `M ${x1} ${y1} L ${x2} ${y2}`;
    }

    function criarLinhaOrtogonal(p1, p2, tipo) {
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', obterCaminhoOrtogonal(p1, p2, tipo));
      return path;
    }

    function obterCorPorStatusEtapa(status) {
      const mapa = {
        'Concluída': { cor: '#38a169', bgCor: 'rgba(56, 161, 105, 0.12)' },
        'Em Andamento': { cor: '#d69e2e', bgCor: 'rgba(214, 158, 46, 0.12)' },
        'Bloqueada': { cor: '#e53e3e', bgCor: 'rgba(229, 62, 62, 0.12)' },
        'A Fazer': { cor: '#718096', bgCor: 'rgba(113, 128, 150, 0.08)' }
      };
      return mapa[status] || mapa['A Fazer'];
    }

    function obterIconeStatus(status) {
      const icones = { 'Concluída': 'fa-check-circle', 'Em Andamento': 'fa-solid fa-arrows-spin', 'Bloqueada': 'fa-ban', 'A Fazer': 'fa-clock' };
      return icones[status] || 'fa-circle';
    }

    function obterIconePorStatus(status) {
       if (status === 'Concluído') return 'fa-check-circle';
       if (status === 'Pausado') return 'fa-pause-circle';
       return 'fa-play-circle';
    }
</script>