<script>
    /* ========================================================================
     * INICIALIZAÇÃO E EVENTOS
     * ======================================================================== */
    document.addEventListener('DOMContentLoaded', function() {
      const salvo = localStorage.getItem('modoEdicaoGlobal');
      if (salvo !== null) modoEdicaoGlobal = salvo === 'true';
      atualizarUIBloqueio();
      configurarEventos();
      carregarDados();
    });

    function tratarErroAssincrono() {}
    
    function configurarEventos() {
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape') { 
          fecharTodosModais(); 
          fecharMenuFlutuante(); 
          cancelarConexao();
          cancelarConexaoResponsavel();
        }
        if (e.ctrlKey && (e.key === '+' || e.key === '=')) { e.preventDefault(); aplicarZoom(0.15); }
        if (e.ctrlKey && e.key === '-') { e.preventDefault(); aplicarZoom(-0.15); }
        if (e.ctrlKey && e.key === '0') { e.preventDefault(); resetarZoom(); }
      });
      
      const area = document.getElementById('areaDiagrama');
      area.addEventListener('mousedown', e => {
        if (e.target === area || e.target.id === 'containerDiagrama' || e.target.classList.contains('svg-conexoes')) {
          iniciarPan(e);
        }
      });

      area.addEventListener('mouseleave', e => {
        if (estado.arrastandoPan) finalizarPan();
        if (estado.elementoArrastando) finalizarArraste();
      });

      document.addEventListener('mousemove', (e) => {
        if (estado.arrastandoPan) { moverPan(e); return; }
        if (estado.elementoArrastando) { moverElemento(e); return; }
        if (estado.conectandoEtapa) desenharLinhaTemp(e);
        if (estado.conectandoResponsavel) desenharLinhaTempResponsavel(e);
      });

      document.addEventListener('mouseup', (e) => {
        if (estado.arrastandoPan) { finalizarPan(); return; }
        if (estado.elementoArrastando) { finalizarArraste(); return; }
        if (!e.target.closest('.ponto-conexao')) {
          if (estado.conectandoEtapa) cancelarConexao();
          if (estado.conectandoResponsavel) cancelarConexaoResponsavel();
        }
      });

      area.addEventListener('wheel', (e) => {
        e.preventDefault();
        const passo = 0.10;
        const direcao = e.deltaY > 0 ? -passo : passo;
        
        const rect = area.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const mundoAntesX = (mouseX - estado.offsetX) / estado.zoom;
        const mundoAntesY = (mouseY - estado.offsetY) / estado.zoom;
        
        estado.zoom = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, estado.zoom + direcao));
        
        const mundoDepoisX = (mouseX - estado.offsetX) / estado.zoom;
        const mundoDepoisY = (mouseY - estado.offsetY) / estado.zoom;
        
        estado.offsetX += (mundoDepoisX - mundoAntesX) * estado.zoom;
        estado.offsetY += (mundoDepoisY - mundoAntesY) * estado.zoom;
        
        aplicarTransform();
        
        const indicador = document.getElementById('indicadorZoom');
        if (indicador) {
            indicador.classList.add('ativo');
            clearTimeout(indicador.timeoutId);
            indicador.timeoutId = setTimeout(() => indicador.classList.remove('ativo'), 500);
        }
        
        const nivelTxt = document.getElementById('zoomNivel');
        if (nivelTxt) nivelTxt.textContent = Math.round(estado.zoom * 100) + '%';
        
      }, { passive: false });
    }

    function isProjetoVisivel(projetoId) {
      if (estado.ocultarTodosProjetos) return false;
      const p = dadosDiagrama.projetos.find(x => x.id === projetoId);
      if (!p) return false;
      if (p.setor && estado.setoresColapsados.has(p.setor)) {
        return false;
      }
      return true;
    }

    /* ========================================================================
     * CARREGAR DADOS
     * ======================================================================== */
function carregarDados() {
  if (!(window.google && google.script && google.script.run)) {
    esconderLoader();
    mostrarToast('Esta página precisa ser aberta como Web App.', 'erro');
    return;
  }
  mostrarLoader();
  google.script.run
    .withSuccessHandler(r => {
      esconderLoader();
      if (r && r.sucesso) {
        dadosDiagrama = {
          projetos: r.projetos || [],
          responsaveis: r.responsaveis || [],
          vinculos: r.vinculos || [],
          etapas: r.etapas || [],
          dependencias: r.dependencias || [],
          setoresResponsaveis: r.setoresResponsaveis || [],
          prioridadesPorResponsavel: new Map()
        };
        
        // NOVO: Armazena permissões do usuário
        if (r.permissoes) {
          permissoesUsuario = {
            nivelAcesso: r.permissoes.nivelAcesso || 'visitante',
            podeCriarProjeto: r.permissoes.podeCriarProjeto || false,
            podeCriarEtapa: r.permissoes.podeCriarEtapa || false,
            ehAdmin: r.permissoes.ehAdmin || false,
            setoresPermitidos: r.permissoes.setoresPermitidos || [],
            projetosPermitidos: r.permissoes.projetosPermitidos || [],
            email: r.permissoes.email || ''
          };
          
          // Permissões carregadas.
        }
        
        podeEditarBackend = r.podeEditar !== false;
        estado.filtroResponsaveis = new Set(dadosDiagrama.responsaveis.map(r => r.id));
        
        cachePosicoesEtapas.clear();
        
        atualizarDatalistSetores();
        renderizarFiltros();
        renderizarFiltrosAvancados();
        renderizarDiagrama();
        atualizarResumo();
        atualizarUIBaseadoEmPermissoes(); // NOVO
        
        carregarPrioridadesTodosResponsaveis();
        
      } else {
        mostrarToast('Erro: ' + (r?.mensagem || 'Desconhecido'), 'erro');
      }
    })
    .withFailureHandler(e => { esconderLoader(); mostrarToast(e.message, 'erro'); })
    .obterDadosDiagrama();
}

/**
 * Atualiza a UI baseado nas permissões do usuário
 */
function atualizarUIBaseadoEmPermissoes() {
  // Botão de criar projeto
  const btnCriarProjeto = document.querySelector('.menu-flutuante-item[onclick*="abrirModalProjeto"]');
  if (btnCriarProjeto) {
    if (!podeCriarProjetoLocal()) {
      btnCriarProjeto.style.display = 'none';
    } else {
      btnCriarProjeto.style.display = '';
    }
  }
  
  // Botão de gerenciar permissões (só admin)
  const btnGerenciarPermissoes = document.getElementById('btnGerenciarPermissoes');
  if (btnGerenciarPermissoes) {
    btnGerenciarPermissoes.style.display = permissoesUsuario.ehAdmin ? '' : 'none';
  }
  
  // Indicador de nível de acesso no header
  atualizarIndicadorNivelAcesso();
}

/**
 * Mostra o nível de acesso do usuário no header
 */
function atualizarIndicadorNivelAcesso() {
  let indicador = document.getElementById('indicadorNivelAcesso');
  
  if (!indicador) {
    // Cria o indicador se não existir
    const cabecalhoCentro = document.querySelector('.cabecalho-centro');
    if (cabecalhoCentro) {
      indicador = document.createElement('div');
      indicador.id = 'indicadorNivelAcesso';
      indicador.className = 'indicador-nivel-acesso';
      cabecalhoCentro.insertBefore(indicador, cabecalhoCentro.firstChild);
    }
  }
  
  if (indicador) {
    const icones = {
      admin: 'fa-shield-halved',
      gestor: 'fa-user-tie',
      colaborador: 'fa-user',
      visitante: 'fa-eye'
    };
    
    const labels = {
      admin: 'Administrador',
      gestor: 'Gestor',
      colaborador: 'Colaborador',
      visitante: 'Visitante'
    };
    
    const nivel = permissoesUsuario.nivelAcesso || 'visitante';
    
    indicador.innerHTML = `
      <i class="fas ${icones[nivel] || 'fa-user'}"></i>
      <span>${labels[nivel] || 'Desconhecido'}</span>
    `;
    
    indicador.className = 'indicador-nivel-acesso nivel-' + nivel;
  }
}

function carregarPrioridadesTodosResponsaveis() {
  if (!dadosDiagrama.responsaveis || dadosDiagrama.responsaveis.length === 0) return;
  
  let carregados = 0;
  const total = dadosDiagrama.responsaveis.length;
  mostrarLoader();
  
  dadosDiagrama.responsaveis.forEach(resp => {
    google.script.run
      .withSuccessHandler(result => {
        if (result && result.sucesso && result.prioridades) {
          dadosDiagrama.prioridadesPorResponsavel.set(resp.id, result.prioridades);
        }
        carregados++;
        
        // Quando todas as prioridades foram carregadas
        if (carregados >= total) {
          atualizarBadgesPrioridadeCards(); // Nova função
          renderizarPainelResponsaveisFixo();
          esconderLoader();
        }
      })
      .withFailureHandler(() => {
        carregados++;
        if (carregados >= total) esconderLoader();
      })
      .obterPrioridadesResponsavel(resp.id);
  });
}
    
    function recarregarDados() { carregarDados(); }

function atualizarDatalistSetores() {
  const lista = document.getElementById('listaSetores');
  if (!lista) return;
  
  lista.innerHTML = '';
  
  // ============================================================
  // CORREÇÃO: Combina setores da aba + setores usados em projetos
  // ============================================================
  const setoresSet = new Set();
  
  // 1. Adiciona setores cadastrados na aba Setores (fonte primária)
  if (dadosDiagrama.setoresResponsaveis && Array.isArray(dadosDiagrama.setoresResponsaveis)) {
    dadosDiagrama.setoresResponsaveis.forEach(s => {
      if (s && s.nomeSetor) {
        setoresSet.add(s.nomeSetor);
      }
    });
  }
  
  // 2. Adiciona setores usados em projetos (compatibilidade com dados antigos)
  if (dadosDiagrama.projetos && Array.isArray(dadosDiagrama.projetos)) {
    dadosDiagrama.projetos.forEach(p => {
      if (p && p.setor && p.setor.trim() !== '') {
        setoresSet.add(p.setor);
      }
    });
  }
  
  // 3. Converte para array, ordena e popula o datalist
  const setoresOrdenados = Array.from(setoresSet).sort((a, b) => 
    a.toLowerCase().localeCompare(b.toLowerCase())
  );
  
  const frag = document.createDocumentFragment();
  setoresOrdenados.forEach(nomeSetor => {
    const opt = document.createElement('option');
    opt.value = nomeSetor;
    frag.appendChild(opt);
  });
  lista.appendChild(frag);
}

// ==========================================
// CRUD DE SETORES
// ==========================================

/**
 * Abre o modal para criar um novo setor
 */
function abrirModalSetor() {
  document.getElementById('setorId').value = '';
  document.getElementById('setorNome').value = '';
  document.getElementById('setorDescricao').value = '';
  
  // Popula o select de responsáveis
  popularSelectSetorResponsavel('');
  
  document.getElementById('modalSetorTituloTexto').textContent = 'Novo Setor';
  document.getElementById('btnExcluirSetor').classList.add('oculto');
  
  abrirModal('modalSetor');
}

/**
 * Abre o modal para editar um setor existente
 * @param {string} setorId - ID do setor (ou nome para compatibilidade)
 */
function editarSetor(setorId) {
  if (!podeEditar()) return;
  
  // Busca o setor pelo ID ou nome
  let setor = null;
  
  if (dadosDiagrama.setoresResponsaveis) {
    setor = dadosDiagrama.setoresResponsaveis.find(s => 
      s.id === setorId || s.nomeSetor === setorId
    );
  }
  
  if (!setor) {
    mostrarToast('Setor não encontrado', 'erro');
    return;
  }
  
  document.getElementById('setorId').value = setor.id || '';
  document.getElementById('setorNome').value = setor.nomeSetor || '';
  document.getElementById('setorDescricao').value = setor.descricao || '';
  
  // Popula o select e seleciona o responsável atual
  popularSelectSetorResponsavel(setor.responsavelId || '');
  
  document.getElementById('modalSetorTituloTexto').textContent = 'Editar Setor';
  document.getElementById('btnExcluirSetor').classList.remove('oculto');
  
  abrirModal('modalSetor');
}

/**
 * Popula o select de responsáveis no modal de setor
 * @param {string} responsavelIdSelecionado - ID do responsável a ser pré-selecionado
 */
function popularSelectSetorResponsavel(responsavelIdSelecionado) {
  const select = document.getElementById('setorResponsavel');
  if (!select) return;
  
  select.innerHTML = '<option value="">Selecione um responsável...</option>';
  
  if (dadosDiagrama.responsaveis && Array.isArray(dadosDiagrama.responsaveis)) {
    dadosDiagrama.responsaveis.forEach(r => {
      if (r && r.id) {
        const option = document.createElement('option');
        option.value = r.id;
        option.textContent = (r.nome || 'Sem nome') + (r.cargo ? ` (${r.cargo})` : '');
        
        if (r.id === responsavelIdSelecionado) {
          option.selected = true;
        }
        
        select.appendChild(option);
      }
    });
  }
}

/**
 * Salva o setor (criar ou atualizar)
 */
function salvarSetor() {
  const id = document.getElementById('setorId').value;
  const nome = document.getElementById('setorNome').value.trim();
  const descricao = document.getElementById('setorDescricao').value.trim();
  const responsavelId = document.getElementById('setorResponsavel').value;
  
  if (!nome) {
    mostrarToast('Nome do setor é obrigatório', 'aviso');
    document.getElementById('setorNome').focus();
    return;
  }
  
  const dadosSetor = {
    nome: nome,
    descricao: descricao,
    responsavelId: responsavelId
  };
  
  mostrarLoader();
  
  const callbackSucesso = function(resultado) {
    esconderLoader();
    
    if (resultado.sucesso) {
      fecharModal('modalSetor');
      
      // Recarrega os dados para atualizar a lista de setores
      carregarDados();
      
      mostrarToast(resultado.mensagem || 'Setor salvo!', 'sucesso');
    } else {
      mostrarToast(resultado.mensagem || 'Erro ao salvar setor', 'erro');
    }
  };
  
  const callbackErro = function(erro) {
    esconderLoader();
    mostrarToast('Erro: ' + erro.message, 'erro');
  };
  
  if (id) {
    // Atualizar existente
    google.script.run
      .withSuccessHandler(callbackSucesso)
      .withFailureHandler(callbackErro)
      .atualizarSetor(id, dadosSetor);
  } else {
    // Criar novo
    google.script.run
      .withSuccessHandler(callbackSucesso)
      .withFailureHandler(callbackErro)
      .adicionarSetor(dadosSetor);
  }
}

/**
 * Confirma e executa a exclusão de um setor
 */
function confirmarExcluirSetor() {
  const id = document.getElementById('setorId').value;
  const nome = document.getElementById('setorNome').value;
  
  if (!id) {
    mostrarToast('Setor não identificado', 'erro');
    return;
  }
  
  if (confirm(`Tem certeza que deseja excluir o setor "${nome}"?\n\nOBS: Só será possível excluir se não houver projetos vinculados.`)) {
    mostrarLoader();
    
    google.script.run
      .withSuccessHandler(function(resultado) {
        esconderLoader();
        
        if (resultado.sucesso) {
          fecharModal('modalSetor');
          carregarDados();
          mostrarToast(resultado.mensagem || 'Setor excluído!', 'sucesso');
        } else {
          mostrarToast(resultado.mensagem || 'Erro ao excluir setor', 'erro');
        }
      })
      .withFailureHandler(function(erro) {
        esconderLoader();
        mostrarToast('Erro: ' + erro.message, 'erro');
      })
      .excluirSetor(id);
  }
}

    /* ========================================================================
     * ORGANIZAÇÃO AUTOMÁTICA (HIERÁRQUICA - SUGIYAMA LIKE)
     * ======================================================================== */
function autoOrganizar() {
  if (!podeEditar()) return;
  abrirModal('modalOrganizacao');
}

function executarOrganizacao() {
  const tipo = estado.layoutSelecionado || CONFIG_ORGANIZACAO.TIPOS_LAYOUT.ARVORE_VERTICAL;
  const espacamento = estado.espacamentoLayout || CONFIG_ORGANIZACAO.ESPACAMENTO_PADRAO;
  
  mostrarLoader();
  fecharModal('modalOrganizacao');
  
  if (tipo === CONFIG_ORGANIZACAO.TIPOS_LAYOUT.ARVORE_VERTICAL) {
    organizarArvoreVertical(espacamento);
  } else if (tipo === CONFIG_ORGANIZACAO.TIPOS_LAYOUT.ARVORE_HORIZONTAL) {
    organizarArvoreHorizontal(espacamento);
  } else {
    organizarGrade(espacamento);
  }
  
  renderizarDiagrama();
  setTimeout(() => {
    centralizarVisao();
    esconderLoader();
    mostrarToast('Layout organizado!', 'sucesso');
  }, 500);
}

function selecionarLayoutOrganizacao(tipo) {
  estado.layoutSelecionado = tipo;
  document.querySelectorAll('.opcao-layout').forEach(el => el.classList.remove('selecionada'));
  document.querySelector(`[data-layout="${tipo}"]`)?.classList.add('selecionada');
}

function atualizarEspacamento(valor) {
  estado.espacamentoLayout = parseInt(valor);
  document.getElementById('valorEspacamento').textContent = valor + 'px';
}

/* ========================================================================
 * FUNÇÃO ATUALIZADA - ABRIR PÁGINA COM ANIMAÇÃO
 * ======================================================================== */
function abrirPaginaProjeto(projetoId) {
  // Encontra o botão clicado pelo ID do projeto e adiciona classe de animação
  const cardProjeto = document.getElementById('projeto-' + projetoId);
  const btnClicado = cardProjeto ? cardProjeto.querySelector('.btn-projeto-detalhe') : null;
  
  if (btnClicado) {
    btnClicado.classList.add('animando-saida');
  }
  
  google.script.run
    .withSuccessHandler(function(urlBase) {
      const urlCompleta = urlBase + '?pagina=projeto&id=' + projetoId;
      
      // Aguarda a animação terminar (400ms) antes de abrir a nova aba
      setTimeout(() => {
        window.open(urlCompleta, '_blank');
        
        // Remove a classe após abrir (caso o usuário volte à aba)
        if (btnClicado) {
          setTimeout(() => {
            btnClicado.classList.remove('animando-saida');
          }, 300);
        }
      }, 350);
    })
    .withFailureHandler(function(erro) {
      mostrarToast('Erro ao abrir página de detalhes', 'erro');
      
      // Remove animação em caso de erro
      if (btnClicado) {
        btnClicado.classList.remove('animando-saida');
      }
    })
    .obterUrlWebApp();
}

    function construirGrafoHierarquico() {
      const grafo = { setores: [], projetos: [], etapas: [], responsaveis: [] };
      
      const setoresUnicos = [...new Set(dadosDiagrama.projetos.map(p => p.setor).filter(s => s))];
      grafo.setores = setoresUnicos.map(nome => ({
        tipo: 'setor', id: nome, nome: nome,
        filhos: dadosDiagrama.projetos.filter(p => p.setor === nome).map(p => p.id)
      }));
      
      grafo.projetos = dadosDiagrama.projetos.map(p => ({
        tipo: 'projeto', id: p.id, nome: p.nome, setor: p.setor,
        filhos: obterEtapasRaiz(p.id).map(e => e.id)
      }));
      
      grafo.etapas = dadosDiagrama.etapas.map(e => ({
        tipo: 'etapa', id: e.id, nome: e.nome, pai: e.etapaPaiId, projeto: e.projetoId,
        filhos: obterEtapasFilhas(e.id).map(f => f.id)
      }));
      
      grafo.responsaveis = dadosDiagrama.responsaveis.map(r => ({
        tipo: 'responsavel', id: r.id, nome: r.nome,
        etapas: dadosDiagrama.etapas.filter(e => e.responsavelId === r.id).map(e => e.id)
      }));
      
      return grafo;
    }

    function calcularNiveis(grafo) {
      const niveis = [];
      niveis[0] = grafo.setores;
      niveis[1] = grafo.projetos;
      
      let nivel = 2;
      let etapasRestantes = [...grafo.etapas];
      
      while (etapasRestantes.length > 0) {
        const etapasNivelAtual = etapasRestantes.filter(e => {
          if (!e.pai) return nivel === 2;
          const paiNivel = niveis.findIndex(n => n.some(item => item.id === e.pai));
          return paiNivel === nivel - 1;
        });
        
        if (etapasNivelAtual.length === 0 && etapasRestantes.length > 0) {
           niveis[nivel] = etapasRestantes; 
           break;
        }

        niveis[nivel] = etapasNivelAtual;
        etapasRestantes = etapasRestantes.filter(e => !etapasNivelAtual.includes(e));
        nivel++;
      }
      
      niveis[nivel] = grafo.responsaveis;
      return niveis;
    }

    function minimizarCruzamentos(niveis) {
      const iteracoes = 5;
      for (let i = 0; i < iteracoes; i++) {
        for (let n = 1; n < niveis.length; n++) {
          ordenarPorBaricentro(niveis[n], niveis[n-1], 'filhos');
        }
        for (let n = niveis.length - 2; n >= 0; n--) {
          ordenarPorBaricentro(niveis[n], niveis[n+1], 'pai');
        }
      }
    }

    function ordenarPorBaricentro(nivelAtual, nivelReferencia, direcao) {
      nivelAtual.forEach(no => {
        const vizinhos = direcao === 'filhos' ? no.filhos : [no.pai].filter(Boolean);
        if (!vizinhos || vizinhos.length === 0) {
          no.baricentro = nivelAtual.indexOf(no);
          return;
        }
        const posicoes = vizinhos.map(v => nivelReferencia.findIndex(item => item.id === v)).filter(p => p >= 0);
        no.baricentro = posicoes.length > 0 ? posicoes.reduce((a, b) => a + b, 0) / posicoes.length : nivelAtual.indexOf(no);
      });
      nivelAtual.sort((a, b) => a.baricentro - b.baricentro);
    }

    function calcularPosicoes(niveis) {
      const CONFIG_LAYOUT = {
        MARGEM_TOPO: 100, MARGEM_ESQUERDA: 100, ESPACO_HORIZONTAL: 350, ESPACO_VERTICAL: 180, ESPACO_RESPONSAVEL: 450
      };
      
      let yAtual = CONFIG_LAYOUT.MARGEM_TOPO;
      
      niveis.forEach((nivel, idx) => {
        let xAtual = CONFIG_LAYOUT.MARGEM_ESQUERDA;
        if (nivel.length < 5) {
          xAtual += (5 - nivel.length) * CONFIG_LAYOUT.ESPACO_HORIZONTAL / 2;
        }
        
        nivel.forEach((no, i) => {
          no.x = xAtual + (i * CONFIG_LAYOUT.ESPACO_HORIZONTAL);
          no.y = yAtual;
        });
        
        if (idx === niveis.length - 1 && nivel[0]?.tipo === 'responsavel') {
          nivel.forEach((resp, i) => {
            resp.x = xAtual + CONFIG_LAYOUT.ESPACO_RESPONSAVEL;
            resp.y = yAtual + (i * 150);
          });
        }
        yAtual += CONFIG_LAYOUT.ESPACO_VERTICAL;
      });
    }

    function aplicarPosicoes(niveis) {
      niveis.forEach(nivel => {
        nivel.forEach(no => {
          switch(no.tipo) {
            case 'setor':
              if (!estado.posicoesSetores) estado.posicoesSetores = {};
              estado.posicoesSetores[no.id] = { x: no.x, y: no.y };
              break;
            case 'projeto':
              const projeto = dadosDiagrama.projetos.find(p => p.id === no.id);
              if (projeto) {
                projeto.posX = no.x; projeto.posY = no.y;
                google.script.run.withFailureHandler(tratarErroAssincrono).atualizarPosicaoProjeto(no.id, no.x, no.y);
              }
              break;
            case 'responsavel':
              const resp = dadosDiagrama.responsaveis.find(r => r.id === no.id);
              if (resp) {
                resp.posX = no.x; resp.posY = no.y;
                google.script.run.withFailureHandler(tratarErroAssincrono).atualizarPosicaoResponsavel(no.id, no.x, no.y);
              }
              break;
            case 'etapa':
               break;
          }
        });
      });
    }

    function centralizarVisao() {
      const area = document.getElementById('areaDiagrama');
      const larguraTotal = 2000;
      const centroX = larguraTotal / 2;
      estado.zoom = 0.7;
      estado.offsetX = (window.innerWidth / 2) - (centroX * estado.zoom);
      estado.offsetY = 50;
      aplicarTransform();
      const nivelTxt = document.getElementById('zoomNivel');
      if (nivelTxt) nivelTxt.textContent = '70%';
    }

    /* ========================================================================
     * PAN, ZOOM E NAVEGAÇÃO
     * ======================================================================== */
    function iniciarPan(e) {
      estado.arrastandoPan = true;
      estado.inicioX = e.clientX;
      estado.inicioY = e.clientY;
      document.getElementById('areaDiagrama').style.cursor = 'grabbing';
    }

    function moverPan(e) {
      if (!estado.arrastandoPan) return;
      const dx = e.clientX - estado.inicioX;
      const dy = e.clientY - estado.inicioY;
      estado.offsetX += dx;
      estado.offsetY += dy;
      estado.inicioX = e.clientX;
      estado.inicioY = e.clientY;
      aplicarTransform();
    }

    function finalizarPan() {
      estado.arrastandoPan = false;
      document.getElementById('areaDiagrama').style.cursor = 'grab';
    }

    function aplicarTransform() {
      const el = document.getElementById('containerDiagrama');
      el.style.transform = `translate(${estado.offsetX}px, ${estado.offsetY}px) scale(${estado.zoom})`;
    }

    function resetarZoom() {
      estado.zoom = 1;
      estado.offsetX = 0;
      estado.offsetY = 0;
      aplicarTransform();
      const nivelTxt = document.getElementById('zoomNivel');
      if (nivelTxt) nivelTxt.textContent = '100%';
    }
    
    function aplicarZoom(delta) {
      estado.zoom = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, estado.zoom + delta));
      aplicarTransform();
      const indicador = document.getElementById('indicadorZoom');
      if (indicador) {
        indicador.classList.add('ativo');
        clearTimeout(indicador.timeoutId);
        indicador.timeoutId = setTimeout(() => indicador.classList.remove('ativo'), 500);
      }
      const nivelTxt = document.getElementById('zoomNivel');
      if (nivelTxt) nivelTxt.textContent = Math.round(estado.zoom * 100) + '%';
    }

    /* ========================================================================
     * ARRASTE E COLISÃO (FRONTEND)
     * ======================================================================== */
    function iniciarArraste(e, tipo, id) {
      if (!podeEditar()) return;
      
      if (tipo === 'etapa') {
        return;
      }
      
      const prefixos = { projeto: 'projeto-', etapa: 'etapa-', setor: 'setor-', responsavel: 'responsavel-' };
      estado.elementoArrastando = document.getElementById((prefixos[tipo] || '') + (tipo === 'setor' ? id.replace(/\s+/g, '-') : id));
      if (!estado.elementoArrastando) return;
      
      document.getElementById('containerDiagrama').classList.add('arrastando-ativo');
      
      estado.elementoArrastando.classList.add('arrastando');
      estado.tipoArrastando = tipo;
      estado.idArrastando = id;
      const rect = estado.elementoArrastando.getBoundingClientRect();
      const areaRect = document.getElementById('areaDiagrama').getBoundingClientRect();
      const elX = (rect.left - areaRect.left - estado.offsetX) / estado.zoom;
      const elY = (rect.top - areaRect.top - estado.offsetY) / estado.zoom;
      const mouseX = (e.clientX - areaRect.left - estado.offsetX) / estado.zoom;
      const mouseY = (e.clientY - areaRect.top - estado.offsetY) / estado.zoom;
      estado.inicioX = mouseX - elX; 
      estado.inicioY = mouseY - elY; 
    }

    function moverElemento(e) {
      if (!estado.elementoArrastando) return;
      e.preventDefault();
      
      const areaRect = document.getElementById('areaDiagrama').getBoundingClientRect();
      const mouseX = (e.clientX - areaRect.left - estado.offsetX) / estado.zoom;
      const mouseY = (e.clientY - areaRect.top - estado.offsetY) / estado.zoom;
      const novoX = mouseX - estado.inicioX;
      const novoY = mouseY - estado.inicioY;
      
      const xAtual = parseFloat(estado.elementoArrastando.style.left) || 0;
      const yAtual = parseFloat(estado.elementoArrastando.style.top) || 0;
      const deltaX = novoX - xAtual;
      const deltaY = novoY - yAtual;
      
      if (estado.frameArrasteAgendado) return; 
      estado.frameArrasteAgendado = true;

      requestAnimationFrame(() => {
        estado.frameArrasteAgendado = false;
        
        estado.elementoArrastando.style.left = novoX + 'px';
        estado.elementoArrastando.style.top = novoY + 'px';
        
        if (estado.tipoArrastando === 'etapa') {
          cachePosicoesEtapas.set(estado.idArrastando, { x: novoX, y: novoY });
        }
        
        if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5) {
          moverFilhosHierarquicosTempoReal(estado.tipoArrastando, estado.idArrastando, deltaX, deltaY);
        }
        
        atualizarConexoesParciais(estado.tipoArrastando, estado.idArrastando);
      });
      
      if (CONFIG_LAYOUT_FLUIDO.DETECTAR_COLISAO_ARRASTE) {
        clearTimeout(estado.timeoutColisaoArraste);
        estado.timeoutColisaoArraste = setTimeout(() => {
          const cardId = estado.elementoArrastando?.id;
          if (cardId) {
            resolverColisoesInteligente(cardId, estado.tipoArrastando);
          }
        }, 100);
      }
    }

    function moverFilhosHierarquicosTempoReal(tipo, id, deltaX, deltaY) {
      if (tipo === 'setor') {
        if (estado.modoMovimentoSetorIndependente.has(id)) {
           redesenharLinhasSetor(id);
           return;
        }

        const projetosDoSetor = dadosDiagrama.projetos.filter(p => p.setor === id);
        projetosDoSetor.forEach(projeto => {
          const cardProjeto = document.getElementById('projeto-' + projeto.id);
          if (cardProjeto) {
            const x = parseFloat(cardProjeto.style.left) || 0;
            const y = parseFloat(cardProjeto.style.top) || 0;
            cardProjeto.style.left = (x + deltaX) + 'px';
            cardProjeto.style.top = (y + deltaY) + 'px';
            
            atualizarConexoesParciais('projeto', projeto.id);
          }
          moverFilhosHierarquicosTempoReal('projeto', projeto.id, deltaX, deltaY);
        });
      } 
      else if (tipo === 'projeto') {
        const etapasDoProjeto = dadosDiagrama.etapas.filter(e => e.projetoId === id);
        etapasDoProjeto.forEach(etapa => {
          const cardEtapa = document.getElementById('etapa-' + etapa.id);
          if (cardEtapa) {
            const x = parseFloat(cardEtapa.style.left) || 0;
            const y = parseFloat(cardEtapa.style.top) || 0;
            cardEtapa.style.left = (x + deltaX) + 'px';
            cardEtapa.style.top = (y + deltaY) + 'px';
            
            if (cachePosicoesEtapas.has(etapa.id)) {
              cachePosicoesEtapas.set(etapa.id, { x: x + deltaX, y: y + deltaY });
            }
            
            atualizarConexoesParciais('etapa', etapa.id);
          }
        });
      }
      else if (tipo === 'etapa') {
        const subEtapas = dadosDiagrama.etapas.filter(e => e.etapaPaiId === id);
        subEtapas.forEach(subEtapa => {
          const cardSub = document.getElementById('etapa-' + subEtapa.id);
          if (cardSub) {
             const x = parseFloat(cardSub.style.left) || 0;
             const y = parseFloat(cardSub.style.top) || 0;
             cardSub.style.left = (x + deltaX) + 'px';
             cardSub.style.top = (y + deltaY) + 'px';

             if (cachePosicoesEtapas.has(subEtapa.id)) {
               cachePosicoesEtapas.set(subEtapa.id, { x: x + deltaX, y: y + deltaY });
             }

             atualizarConexoesParciais('etapa', subEtapa.id);

             moverFilhosHierarquicosTempoReal('etapa', subEtapa.id, deltaX, deltaY);
          }
        });
      }
    }

    function finalizarArraste() {
      if (!estado.elementoArrastando) return;
      
      const el = estado.elementoArrastando;
      const tipo = estado.tipoArrastando;
      const id = estado.idArrastando;
      
      document.getElementById('containerDiagrama').classList.remove('arrastando-ativo');
      
      el.classList.remove('arrastando');
      
      const novoX = parseFloat(el.style.left);
      const novoY = parseFloat(el.style.top);
      
      atualizarModeloPosicao(tipo, id, novoX, novoY);
      
      const cardId = el.id;
      processarColisoesCascata(cardId, tipo);
      
      salvarPosicaoAsync(tipo, id, novoX, novoY);
      
      estado.elementoArrastando = null;
      estado.tipoArrastando = null;
      estado.idArrastando = null;
    }

    /* ========================================================================
     * CONEXÕES E VÍNCULOS
     * ======================================================================== */
    function iniciarConexao(etapaId, anchor, elPonto) {
       estado.conectandoEtapa = etapaId;
       estado.anchorOrigem = anchor;
       estado.pontoOrigem = obterPosAnchor(elPonto.parentElement, anchor); 
    }

    function finalizarConexao(etapaDestinoId) {
       if (!estado.conectandoEtapa) return;
       const origem = estado.conectandoEtapa;
       const destino = etapaDestinoId;
       if (origem === destino) return;
       google.script.run.withSuccessHandler(r => {
          if (r.sucesso) {
             dadosDiagrama.dependencias.push({ id: r.id, origem, destino, etapaOrigemId: origem, etapaDestinoId: destino });
             renderizarDiagrama();
             mostrarToast('Dependência criada!', 'sucesso');
          } else {
             mostrarToast(r.mensagem, 'erro');
          }
       }).adicionarDependencia({ etapaOrigemId: origem, etapaDestinoId: destino });
       cancelarConexao();
    }

    function cancelarConexao() {
       estado.conectandoEtapa = null;
       const l = document.getElementById('linha-temp');
       if(l) l.remove();
    }



    function navegarParaResponsavel(respId) {
      const card = document.getElementById('responsavel-' + respId);
      if (!card) { mostrarToast('Responsável não visível', 'aviso'); return; }
      navegarParaElemento(card);
      card.style.animation = 'none';
      setTimeout(() => card.style.animation = 'pulseDestaque 0.6s ease 2', 10);
    }

    function navegarParaProjeto(projetoId) {
      const card = document.getElementById('projeto-' + projetoId);
      if (!card) { mostrarToast('Projeto não visível', 'aviso'); return; }
      navegarParaElemento(card);
      card.style.animation = 'none';
      setTimeout(() => card.style.animation = 'pulseDestaque 0.6s ease 2', 10);
    }

    function navegarParaSetor(nomeSetor) {
      const cardId = 'setor-' + nomeSetor.replace(/\s+/g, '-');
      const card = document.getElementById(cardId);
      if (!card) { mostrarToast('Setor não visível', 'aviso'); return; }
      navegarParaElemento(card);
      card.style.animation = 'none';
      setTimeout(() => card.style.animation = 'pulseDestaque 0.6s ease 2', 10);
    }
    
    function navegarParaElemento(elemento) {
      const area = document.getElementById('areaDiagrama');
      const areaRect = area.getBoundingClientRect();
      const posX = parseFloat(elemento.style.left);
      const posY = parseFloat(elemento.style.top);
      const largura = elemento.offsetWidth;
      const altura = elemento.offsetHeight;
      const centroViewportX = areaRect.width / 2;
      const centroViewportY = areaRect.height / 2;
      const centroElementoX = posX + (largura / 2);
      const centroElementoY = posY + (altura / 2);
      estado.offsetX = centroViewportX - (centroElementoX * estado.zoom);
      estado.offsetY = centroViewportY - (centroElementoY * estado.zoom);
      const container = document.getElementById('containerDiagrama');
      container.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
      aplicarTransform();
      setTimeout(() => container.style.transition = '', 600);
    }
    
    function navegarParaEtapa(etapaId) {
      const card = document.getElementById('etapa-' + etapaId);
      if (!card) { mostrarToast('Etapa não encontrada no canvas', 'aviso'); return; }
      navegarParaElemento(card);
      card.style.animation = 'none';
      setTimeout(() => card.style.animation = 'pulseDestaque 0.6s ease 2', 10);
    }

function organizarArvoreVertical(espacamento) {
  const MARGEM_TOPO = 80;
  const MARGEM_ESQUERDA = 100;
  const ESPACO_H = espacamento + 200; 
  const ESPACO_V = espacamento + 60;  
  
  const setores = [...new Set(dadosDiagrama.projetos.map(p => p.setor).filter(s => s))];
  const projetosSemSetor = dadosDiagrama.projetos.filter(p => !p.setor);
  
  let xAtualSetor = MARGEM_ESQUERDA;
  
  setores.forEach((nomeSetor, idxSetor) => {
    const projetosDoSetor = dadosDiagrama.projetos.filter(p => p.setor === nomeSetor);
    const larguraSetor = Math.max(1, projetosDoSetor.length) * ESPACO_H;
    
    const xSetor = xAtualSetor + (larguraSetor / 2) - 140; 
    const ySetor = MARGEM_TOPO;
    
    if (!estado.posicoesSetores) estado.posicoesSetores = {};
    estado.posicoesSetores[nomeSetor] = { x: xSetor, y: ySetor };
    
    projetosDoSetor.forEach((projeto, idxProjeto) => {
      const xProjeto = xAtualSetor + (idxProjeto * ESPACO_H);
      const yProjeto = ySetor + ESPACO_V;
      
      projeto.posX = xProjeto;
      projeto.posY = yProjeto;
      
      posicionarEtapasProjetoVertical(projeto.id, xProjeto, yProjeto + ESPACO_V, espacamento);
      
      google.script.run.withFailureHandler(tratarErroAssincrono)
        .atualizarPosicaoProjeto(projeto.id, xProjeto, yProjeto);
    });
    
    xAtualSetor += larguraSetor + espacamento;
  });
  
  if (projetosSemSetor.length > 0) {
    projetosSemSetor.forEach((projeto, idx) => {
      const xProjeto = xAtualSetor + (idx * ESPACO_H);
      const yProjeto = MARGEM_TOPO + ESPACO_V;
      
      projeto.posX = xProjeto;
      projeto.posY = yProjeto;
      
      posicionarEtapasProjetoVertical(projeto.id, xProjeto, yProjeto + ESPACO_V, espacamento);
      
      google.script.run.withFailureHandler(tratarErroAssincrono)
        .atualizarPosicaoProjeto(projeto.id, xProjeto, yProjeto);
    });
  }
}

/**
 * Posiciona etapas de um projeto em formato de árvore vertical
 */
function posicionarEtapasProjetoVertical(projetoId, xBase, yBase, espacamento) {
  const etapasRaiz = dadosDiagrama.etapas.filter(e => e.projetoId === projetoId && !e.etapaPaiId);
  const ESPACO_H_ETAPA = espacamento + 50;
  const ESPACO_V_ETAPA = espacamento + 20;
  
  etapasRaiz.forEach((etapa, idx) => {
    const xEtapa = xBase + (idx * ESPACO_H_ETAPA);
    const yEtapa = yBase;
    
    etapa.offsetX = xEtapa - xBase + (idx * 50);
    etapa.offsetY = ESPACO_V_ETAPA;
    
    posicionarSubEtapasVertical(etapa.id, xEtapa, yEtapa, espacamento, 1);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoEtapa(etapa.id, etapa.offsetX, etapa.offsetY);
  });
}

/**
 * Posiciona sub-etapas recursivamente em formato vertical
 */
function posicionarSubEtapasVertical(etapaPaiId, xPai, yPai, espacamento, nivel) {
  const subEtapas = dadosDiagrama.etapas.filter(e => e.etapaPaiId === etapaPaiId);
  const ESPACO_H = espacamento * 0.6;
  const ESPACO_V = espacamento * 0.5;
  
  subEtapas.forEach((subEtapa, idx) => {
    subEtapa.offsetX = (idx * ESPACO_H) + (nivel * 30);
    subEtapa.offsetY = ESPACO_V * (nivel + 1);
    
    posicionarSubEtapasVertical(subEtapa.id, xPai + subEtapa.offsetX, yPai + subEtapa.offsetY, espacamento, nivel + 1);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoEtapa(subEtapa.id, subEtapa.offsetX, subEtapa.offsetY);
  });
}

/**
 * Organiza os cards em formato de árvore horizontal
 * Setores à esquerda, projetos ao lado, etapas à direita
 */
function organizarArvoreHorizontal(espacamento) {
  const MARGEM_TOPO = 80;
  const MARGEM_ESQUERDA = 100;
  const ESPACO_H = espacamento + 280; 
  const ESPACO_V = espacamento + 40;  
  
  const setores = [...new Set(dadosDiagrama.projetos.map(p => p.setor).filter(s => s))];
  const projetosSemSetor = dadosDiagrama.projetos.filter(p => !p.setor);
  
  let yAtualSetor = MARGEM_TOPO;
  
  setores.forEach((nomeSetor, idxSetor) => {
    const projetosDoSetor = dadosDiagrama.projetos.filter(p => p.setor === nomeSetor);
    const alturaSetor = Math.max(1, projetosDoSetor.length) * ESPACO_V;
    
    const xSetor = MARGEM_ESQUERDA;
    const ySetor = yAtualSetor + (alturaSetor / 2) - 60;
    
    if (!estado.posicoesSetores) estado.posicoesSetores = {};
    estado.posicoesSetores[nomeSetor] = { x: xSetor, y: ySetor };
    
    projetosDoSetor.forEach((projeto, idxProjeto) => {
      const xProjeto = xSetor + ESPACO_H;
      const yProjeto = yAtualSetor + (idxProjeto * ESPACO_V);
      
      projeto.posX = xProjeto;
      projeto.posY = yProjeto;
      
      posicionarEtapasProjetoHorizontal(projeto.id, xProjeto + ESPACO_H - 100, yProjeto, espacamento);
      
      google.script.run.withFailureHandler(tratarErroAssincrono)
        .atualizarPosicaoProjeto(projeto.id, xProjeto, yProjeto);
    });
    
    yAtualSetor += alturaSetor + espacamento;
  });
  
  if (projetosSemSetor.length > 0) {
    projetosSemSetor.forEach((projeto, idx) => {
      const xProjeto = MARGEM_ESQUERDA + ESPACO_H;
      const yProjeto = yAtualSetor + (idx * ESPACO_V);
      
      projeto.posX = xProjeto;
      projeto.posY = yProjeto;
      
      posicionarEtapasProjetoHorizontal(projeto.id, xProjeto + ESPACO_H - 100, yProjeto, espacamento);
      
      google.script.run.withFailureHandler(tratarErroAssincrono)
        .atualizarPosicaoProjeto(projeto.id, xProjeto, yProjeto);
    });
  }
}

/**
 * Posiciona etapas de um projeto em formato horizontal
 */
function posicionarEtapasProjetoHorizontal(projetoId, xBase, yBase, espacamento) {
  const etapasRaiz = dadosDiagrama.etapas.filter(e => e.projetoId === projetoId && !e.etapaPaiId);
  const ESPACO_V_ETAPA = espacamento * 0.6;
  
  etapasRaiz.forEach((etapa, idx) => {
    etapa.offsetX = espacamento + 100;
    etapa.offsetY = (idx * ESPACO_V_ETAPA) - ((etapasRaiz.length - 1) * ESPACO_V_ETAPA / 2);
    
    posicionarSubEtapasHorizontal(etapa.id, xBase + etapa.offsetX, yBase + etapa.offsetY, espacamento, 1);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoEtapa(etapa.id, etapa.offsetX, etapa.offsetY);
  });
}

/**
 * Posiciona sub-etapas recursivamente em formato horizontal
 */
function posicionarSubEtapasHorizontal(etapaPaiId, xPai, yPai, espacamento, nivel) {
  const subEtapas = dadosDiagrama.etapas.filter(e => e.etapaPaiId === etapaPaiId);
  const ESPACO_H = espacamento * 0.8;
  const ESPACO_V = espacamento * 0.4;
  
  subEtapas.forEach((subEtapa, idx) => {
    subEtapa.offsetX = ESPACO_H * nivel + 150;
    subEtapa.offsetY = (idx * ESPACO_V) + (nivel * 20);
    
    posicionarSubEtapasHorizontal(subEtapa.id, xPai + ESPACO_H, yPai + subEtapa.offsetY, espacamento, nivel + 1);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoEtapa(subEtapa.id, subEtapa.offsetX, subEtapa.offsetY);
  });
}

/**
 * Organiza os cards em formato de grade uniforme
 */
function organizarGrade(espacamento) {
  const MARGEM_TOPO = 80;
  const MARGEM_ESQUERDA = 100;
  const ESPACO_H = espacamento + 320; 
  const ESPACO_V = espacamento + 200; 
  
  const totalProjetos = dadosDiagrama.projetos.length;
  const colunas = Math.max(2, Math.ceil(Math.sqrt(totalProjetos)));
  
  const projetosOrdenados = [...dadosDiagrama.projetos].sort((a, b) => {
    if (a.setor && b.setor) return a.setor.localeCompare(b.setor);
    if (a.setor) return -1;
    if (b.setor) return 1;
    return 0;
  });
  
  projetosOrdenados.forEach((projeto, idx) => {
    const coluna = idx % colunas;
    const linha = Math.floor(idx / colunas);
    
    const xProjeto = MARGEM_ESQUERDA + (coluna * ESPACO_H);
    const yProjeto = MARGEM_TOPO + (linha * ESPACO_V);
    
    projeto.posX = xProjeto;
    projeto.posY = yProjeto;
    
    posicionarEtapasProjetoGrade(projeto.id, espacamento);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoProjeto(projeto.id, xProjeto, yProjeto);
  });
  
  const setores = [...new Set(dadosDiagrama.projetos.map(p => p.setor).filter(s => s))];
  let xSetorAtual = MARGEM_ESQUERDA;
  
  setores.forEach((nomeSetor, idx) => {
    if (!estado.posicoesSetores) estado.posicoesSetores = {};
    estado.posicoesSetores[nomeSetor] = { 
      x: xSetorAtual + (idx * ESPACO_H * 1.5), 
      y: 20 
    };
  });
}

/**
 * Posiciona etapas de um projeto em formato de grade
 */
function posicionarEtapasProjetoGrade(projetoId, espacamento) {
  const etapasRaiz = dadosDiagrama.etapas.filter(e => e.projetoId === projetoId && !e.etapaPaiId);
  const ESPACO_H = espacamento * 0.5;
  const ESPACO_V = espacamento * 0.4;
  
  etapasRaiz.forEach((etapa, idx) => {
    const coluna = idx % 2;
    const linha = Math.floor(idx / 2);
    
    etapa.offsetX = 20 + (coluna * ESPACO_H);
    etapa.offsetY = 180 + (linha * ESPACO_V);
    
    posicionarSubEtapasGrade(etapa.id, espacamento, 1);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoEtapa(etapa.id, etapa.offsetX, etapa.offsetY);
  });
}

/**
 * Posiciona sub-etapas em formato de grade cascateada
 */
function posicionarSubEtapasGrade(etapaPaiId, espacamento, nivel) {
  const subEtapas = dadosDiagrama.etapas.filter(e => e.etapaPaiId === etapaPaiId);
  const ESPACO = espacamento * 0.35;
  
  subEtapas.forEach((subEtapa, idx) => {
    subEtapa.offsetX = (nivel * 40) + (idx * ESPACO * 0.5);
    subEtapa.offsetY = ESPACO * (idx + 1) + (nivel * 30);
    
    posicionarSubEtapasGrade(subEtapa.id, espacamento, nivel + 1);
    
    google.script.run.withFailureHandler(tratarErroAssincrono)
      .atualizarPosicaoEtapa(subEtapa.id, subEtapa.offsetX, subEtapa.offsetY);
  });
}

/**
 * Funções auxiliares para obter etapas
 */
function obterEtapasRaiz(projetoId) {
  return dadosDiagrama.etapas.filter(e => e.projetoId === projetoId && !e.etapaPaiId);
}

function obterEtapasFilhas(etapaPaiId) {
  return dadosDiagrama.etapas.filter(e => e.etapaPaiId === etapaPaiId);
}
</script>
